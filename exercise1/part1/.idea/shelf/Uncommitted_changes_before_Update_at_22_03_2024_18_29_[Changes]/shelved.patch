Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Esercizio 1\r\n\r\n## Obiettivi:\r\n- Gestione stringhe e slice\r\n- Differenza tra \"caratteri\" (char) e \"byte\" (u8) in Rust\r\n- Lettura parametri da command line\r\n\r\nCon il termine \"slug\" si intende una stringa convertita in formato leggibile, composta solo dai caratteri `[a-z][0-9]-`.\r\n\r\nNella stringa originale i caratteri non ammissibili vengono convertiti seguendo queste regole:\r\n- Tutti i caratteri accentati riconosciuti vengono convertiti nell'equivalente non accentato\r\n- Tutto viene convertito in minuscolo\r\n- Ogni altro carattere rimanente che non sia in `[a-z][0-9]` viene convertito in \"-\"\r\n- Due \"-\" consecutivi non sono ammessi, solo il primo viene tenuto\r\n- Un \"-\" finale non è ammesso a meno che non sia l'unico carattere nella stringa\r\n\r\nL'obiettivo dell'esercizio è fare una funzione \"slugify\" che converta una stringa generica in uno slug.\r\n\r\n## Passi per la soluzione:\r\n1. Creare con cargo un nuovo package chiamato `slugify` e, in `main.rs`, definire la funzione `slugify`.\r\n\r\n```rust\r\nfn slugify(s: &str) -> String {}\r\n```\r\n2. Per convertire le lettere accentate definire una funzione che esegua la conversione:\r\n\r\n```rust\r\nfn conv(c: char) -> char {}\r\n```\r\nConv restituisce il carattere c se è uno ammesso, la lettera non accentata\r\ncorrispondente se viene trovata, o “-” negli altri casi\r\nAll’interno usare questa tabella di conversione, dove il carattere nella posizione i\r\n(come carattere) in SUBS_I corrisponde al carattere nella posizione i in SUBS_O:\r\n\r\n```rust\r\nconst SUBS_I : &str =\r\n    \"àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìıİłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż\";\r\nconst SUBS_O: &str =\r\n    \"aaaaaaaaaacccddeeeeeeeegghiiiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzz\r\nz\";\r\n```\r\nATTENZIONE: SUBS_I e SUBS_O essendo degli slice di stringa non possono\r\nessere indicizzati direttamente con [pos] (perché?), tutto quello che si può assumere\r\nè che il carattere corrispondente alla posizione i-esima di SUBS_I è nella stessa\r\nposizione in SUBS_O.\r\n\r\n3. Scrivere degli unit test per le funzioni create\r\n   (riferimento: https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html)\r\n- a. creare una sezione in main.rs per ospitare i test:\r\n\r\n```rust\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n}\r\n```\r\n\r\n- b. i test sono funzioni così definite all’interno:\r\n```rust\r\n#[test]\r\nfn my_first_test() {\r\n// valore = preparazione test\r\n    assert_eq!(valore, valore_atteso)\r\n}\r\n```\r\n\r\n- c. definire almeno questi test:\r\n  i. conversione lettera accentata\r\n  ii. conversione lettera non accentata\r\n  iii. conversione lettera non ammessa sconosciuta\r\n  iv. conversione lettera accentata non compresa nella lista (es ῶ)\r\n  v. stringa con più di una parola separata da spazio\r\n  vi. stringa con caratteri accentati\r\n  vii. stringa vuota\r\n  viii. stringa con più spazi consecutivi\r\n  ix. stringa con con più caratteri non validi consecutivi\r\n  x. stringa con solo caratteri non validi\r\n  xi. stringa con spazio alla fine\r\n  xii. stringa con più caratteri non validi consecutivi alla fine\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 430e8eab7bbdd853c835818172c8121d1cc342a7)
+++ b/README.md	(date 1711128542752)
@@ -77,3 +77,4 @@
   x. stringa con solo caratteri non validi
   xi. stringa con spazio alla fine
   xii. stringa con più caratteri non validi consecutivi alla fine
+
